# 운영체제

복습: No
사용: cs
작성일시: 2022년 12월 13일 오후 2:40

운영체제 좁은 의미 : 커널

## ✨ 운영체제 목적

1. 효율성
2. 형평성

![Untitled](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20966512d1ee974e96abca1ebf249fc937/Untitled.png)

## ✨ 운영체제 분류

유저 프로그램 ~ 하드웨어

- GUI : 사용자가 전자장치와 상호 작용할 수 있도록 하는 사용자 인터페이스의 한 형태, 단순 명령어 창이 아닌 아이콘을 마우스로 클릭하는 단순한 동작으로 컴퓨터와 상호작용
- 시스템콜 : 운영체제가 커널에 접근하기 위한 인터페이스, 유저 프로그램이 운영체제의 서비스를 받기 위해 커널함수를 호출할 때 사용
    
    하나의 추상화 계층 
    
    - modebit : 유저모드와 커널 모드를 구분한다.(1 <유저모드>or 0 <커널모드>값을 가지는 플래그 변수)
    - 유저모드 : 유저가 접근할수 있는 영역을 제한적으로 두며 컴퓨터 자원에 함부로 침범하지 못하게 하는 모드
    - 커널 모드 : 모든 컴퓨터 자원에 접근 할수 있는 모드
- 커널
- 드라이버 : 하드웨어를 제어하기 위한 소프트웨어
- CUI : 그래픽이 아닌 명령어로 처리하는 인터페이스 (리눅스)

## ✨ 컴퓨터 요소

![Untitled](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20966512d1ee974e96abca1ebf249fc937/Untitled%201.png)

- CPU : 산술논리 연산장치, 제어장치, 레지스터로 구성되어 있는 컴퓨터 장치
    
    인터럽터에 의해 단순히 메모리에 존재하는 명령어를 해석해서 실행하는 일꾼
    
    커널이 프로그램을 메모리에 올려 프로세스로 만들면 CPU가 처리
    
- 제어장치 : 프로세스 조작을 지시하는 cpu의 한 부품, 입출력 장치 간 통신을 제어하고 명령어를 읽고 해석하며 데이터를 처리하기 위한 순서를 결정
- 레지스터 : cpu의 매우 빠른 임시 기억장치

레지스터는 CPU의 데이터 처리 속도를 높이기 위해 도입되었다.CPU의 데이터 처리 속도에 큰 영향을 미치는 요소 중에 하나가, 바로 Memory access time이었다. CPU가 메모리에 직접 접근해서 데이터를 꺼내오는 것이 상당한 시간을 소요했던 것이다.

ㅇ 연산처리 : 제어장치에서 메모리에 계산할 값을 로드 → 레지스터로 로드 → 레지스터에 있는 값을 계산 → 다시 레지스터에서 메모리로 계산한 값을 저장

- 인터럽트 : 신호가 들어왔을 때 cpu를 잠시 정지시키는 것
    
    잠시 정지 했을 때 상태레지스터와 pc등을 스택에 잠시 저장한 뒤에 인터럽트 서비스 루틴으로 간다. (루틴 끝난 뒤 다시 원래 작업으로 돌아와야 되기 때문)
    입출력 이나 예외상황이 발생시 마이크로프로세서에 알려 처리할수 있게 하는 것
    인터럽트 발생 시, 인터럽트 핸들러 함수가 모여있는 인터럽트 벡터로 가서 인터럽트 핸들러 함수가 실행된다. 서로간에 우선순위가 있으며, 종류는 2가지이다.
    
    - 하드웨어 인터럽트 : 키보드를 연결하거나 마우스를 연결하는 등의 IO디바이스에서 발생하는 인터럽트(전원 이상, 기계 착오, 외부 신호, 입출력)
    - 소프트웨어 인터럽트 : 트랩이라고 한다. 프로세스 오류 등으로 프로세스가 시스템콜을 호출할 때 발동
    
    cf) CPU가 수행하는 명령에는 일반 명령과 특권 명령이 있다.
    일반 명령은 메모리에서 자료를 읽어오고, cpu에서 계산을 하는 등의 명령이고 모든 프로그램이 수행할 수 있는 명령
    
    특권 명령은 보안이 필요한 명령으로 입출력 장치, 타이머 등의 장치를 접근하는 명령, 운영 체제만이 수행할 수 있다.
    

### **인터럽트 발생 처리 과정**

---

![https://mblogthumb-phinf.pstatic.net/20160310_124/scw0531_14575366291105WjS7_PNG/ERTRTETRE.png?type=w2](https://mblogthumb-phinf.pstatic.net/20160310_124/scw0531_14575366291105WjS7_PNG/ERTRTETRE.png?type=w2)

주 프로그램이 실행되다가 인터럽트가 발생했다.

현재 수행 중인 프로그램을 멈추고, 상태 레지스터와 PC 등을 스택에 잠시 저장한 뒤에 인터럽트 서비스 루틴으로 간다. (잠시 저장하는 이유는, 인터럽트 서비스 루틴이 끝난 뒤 다시 원래 작업으로 돌아와야 하기 때문)

만약 **인터럽트 기능이 없었다면**, 컨트롤러는 특정한 어떤 일을 할 시기를 알기 위해 계속 체크를 해야 한다. (이를 폴링(Polling)이라고 한다)

**폴링**을 하는 시간에는 원래 하던 일에 집중할 수가 없게 되어 많은 기능을 제대로 수행하지 못하는 단점이 있었다.

즉, 컨트롤러가 입력을 받아들이는 방법(우선순위 판별방법)에는 두가지가 있다.

- **폴링 방식**
    
    사용자가 명령어를 사용해 입력 핀의 값을 계속 읽어 변화를 알아내는 방식
    
    인터럽트 요청 플래그를 차례로 비교하여 우선순위가 가장 높은 인터럽트 자원을 찾아 이에 맞는 인터럽트 서비스 루틴을 수행한다. (하드웨어에 비해 속도 느림)
    
- **인터럽트 방식**
    
    MCU 자체가 하드웨적으로 변화를 체크하여 변화 시에만 일정한 동작을 하는 방식
    
    - Daisy Chain
    - 병렬 우선순위 부여

인터럽트 방식은 하드웨어로 지원을 받아야 하는 제약이 있지만, 폴링에 비해 신속하게 대응하는 것이 가능하다. 따라서 **실시간 대응**이 필요할 때는 필수적인 기능이다.

즉, 인터럽트는 **발생시기를 예측하기 힘든 경우에 컨트롤러가 가장 빠르게 대응할 수 있는 방법**이다.

- DMA 컨트롤러 : I/O디바이스가 메모리에 직접 접근할수 있도록 하는 하드웨어 장치
CPU에만 너무 많은 인터럽트 요청이 들어오기 때문에 CPU의 부하를 막아주며 일을 분담하는 보조장치, 동시에 같은 일을 하는 것도 방지한다.
- 메모리 : 데이터의 상태, 명령어 등을 기록, RAM, 메모리가 크면 → 많은 일을 동시에 처리
- 타이머 : 특정 프로그램에 시간을 제한
- 디바이스 컨트롤러 : 컴퓨터와 연결되어 있는 IO디바이스들의 작은 CPU를 의미

## ✨ 메모리

- 메모리 계층
    1. 레지스터
    2. 캐시(L1,L2)
    3. 메모리(RAM) / 주기억장치
    4. 저장장치(HDD, SDD) / 보조기억장치

![Untitled](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20966512d1ee974e96abca1ebf249fc937/Untitled%202.png)

레지스터 : CPU내부에 위치하기 때문에 고속으로 데이터 처리 가능, 단 용량이 작음,

- 데이터 레지스터 : CPU가 명령어를 처리하는 과정에서 임시로 처리할 데이터를 저장하거나 메모리의 주소를 저장할 목적으로 사용
- 제어용 레지스터 : CPU가 프로그램의 실행 흐름을 제어하거나 상태를 저장하기 위해 사용되는 레지스터

RAM : CPU가 데이터에 접근하기 위해서 물리적으로 돌아가야되서 오래걸림

캐시 : 데이터를 미리 복사해놓은 임시 저장소이자 빠른 장치와 느린 장치의 속도차이에 따른 병목현상을 줄이기 위한 메모리 상위 계층과 하위 계층 사이에서 조율하는 것을 캐싱 계층이라고한다.

- 캐시히트 : 캐시에서 원하는 자료를 찾음(빠름)
- 캐시미스 : 캐시에 없어서 주 메모리에서 데이터를 찾는 것(느림) 시스템 버스를 기반으로 하기 때문
- 캐시매핑 : 캐시 히트되기 위해 매핑하는 방법, cpu의 레지스터와 RAM간에 데이터를 주고받을 때를 기반으로 설명
종류 : 직접매핑, 연관매핑, 집합연관매핑

자주 사용하는 데이터를 기반으로 캐시 계층을 둔다.

---

- 지역성이 근거!!
- 시간 지역성 : 최근에 사용한 데이터에 다시 접근
- 공간 지역성 : 최근 접근한 데이터를 이루고 있는 공간이나 그 가까운 공간에 접근

웹브라우저의 캐시 종류

---

- 쿠키 : 만료기한이 있는 키-값 저장소, 4KB까지 저장
- 로컬 스토리지 : 만료기한이 없는 키-값 저장소, 10MB까지 저장, 웹브라우저 닫아도 유지되고 도메인 단위로 저장, 생성된다.HTML5를 지원하지 않는 웹브라우저에서는 사용할수 없으며 클라이언트 에서만 수정 가능
- 세션 스토리지 : 만료기한이 없는 키-값 저장소, 탭 단위로 세션 스토리지를 생성하며, 탭을 닫을 때 해당 데이터가 삭제된다. 5MB까지 저장가능하며 HTML5지원하지 않는 웹브라우저에서 사용할수 없고 클라이언트에서만 수정 가능

## ✨ 메모리 관리

운영체제의 할일 중 하나

### 🎈가상메모리

메모리 자원을 추상화해서 사용자에게 매우 큰 메모리로 보이게 하는 것

가상 주소 : 가상으로 주어지는 주소 → 메모리 관리장치(MMU)에 의해 실제 주소로 변환

실제 주소 : 실제 메모리상에 있는 주소

속도 향상을 위해서 TLB를 사용 _→ TLB : 메모리와 CPU사이에 있는 주소 변환을 위한 캐시, 페이지 테이블에있는 리스트를 보관하며 CPU가 페이지 테이블까지 가지 않도록 해 속도를 향상시킬수 있는 캐시 계층

스와핑 : 가상 메모리에는 존재하지만 실제 메모리인 RAM에는 현재 없는 데이터나 코드에 접근할 경우 페이지 폴트가 발생합니다. 이를 방지하기 위해 당장 사용하지 않는 영역을 하드디스크로 옮겨 필요할 때만 RAM으로 불러와 올리고, 다시 하드디스크로 내려 관리하는 것을 스와핑이라고 한다.

페이지 폴트 : 프로세스의 주소 공간에는 존재하지만 지금 이컴퓨터의 RAM에는 존재하지 않는 데이터에 접근했을 때 생기는 현상→ 스와핑 과정

1. CPU는 물리 메모리를 확인해 해당 페이지가 없으면 트랩을 발생해서 운영체제에 알린다.
2. 운영체제는 CPU의 동작을 잠시 멈춘다.
3. 운영체제는 페이지 테이블을 확인해 가상 메모리에 페이지의 존재를 확인하고 없으면, 프로세스를 중단하고 물리메모리에 비어 있는 프레임이 있는지 찾는다. 물리메모리에 없으면 스와핑이 발동
4. 비어 있는 프레임에 해당 페이지를 로드하고, 페이지 테이블을 최신화한다.
5. 중단되었던 CPU를 다시 시작한다.

페이지 : 가상 메모리를 사용하는 최소 크기 단위

프레임 : 실제 메모리를 사용하는 최소 크기 단위

### 🎈스레싱

스레싱은 메모리의 페이지 폴트율이 높은 것을 의미, 이것은 컴퓨터 성능 저하로 이어진다.

메모리에 너무 많은 프로세스가 동시에 올라가면 스와핑이 많이 일어나서 발생하는 것.

해결 방법 : 메모리를 늘리거나 HDD를 사용하면 SDD로 변경하는 방법, 작업세트, PFF

작업세트 : 프로세스의 과거 사용 이력인 지역성을 통해 결정된 페이지 집합을 만들어서 미리 메모리에 로드하는 것

PFF(Page Fault Frequency) 는 페이지 폴트 빈도를 조절하는 방법으로 상한선과 하한선을 만드는 방법 : 상한선에 도달하면 페이지를 늘리고 하한선에 도착하면 페이지를 줄임

메모리 할당 : 시작 메모리 위치, 메모리 할당 크기를 기반으로 할당한다. 종류는 2가지

1. 연속 할당 : 메모리에 연속적으로 공간을 할당하는 것
    - 고정 분할 방식 : 메모리를 미리 나누어 관리하는 방식, 융통성이 없다.
    - 가변 분할 방식 : 프로그램 크기에 맞게 동적으로 메모리를 나눠 사용합니다.
2. 불연속 할당 : 메모리를 동일한 크기의 페이지로 나누고 프로그램마다 페이지 테이블을 두어 이를 통해 메모리에 프로그램을 할당하는 것
    - 페이징 : 동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 프로세스를 할당
    - 세그멘테이션 : 의미단위인 세그먼트로 나누는 방식, 코드와 데이터등 이를 기반으로 나눌수 있고 함수 단위로 나눌수 있다. 다만 홀 크기가 균일하지 않은 문제 발생
    - 페이지드 세그멘테이션 : 공유나 보안을 의미 단위의 세그먼트로 나누고 물리적 메모리는 페이지로 나누는 것
- 페이지 교체 알고리즘 : 스와핑이 많이 일어나지 않도록 설계
    - FIFO : 가장 먼저온 페이지를 교체역역에 놓는 방법
    - LRU : 참조가 가장 오래된 페이지를 바꾸는것 → 페이지마다 계수기, 스택을 두어야한다.
    - NUR : 0과 1로 비트를 두고 1은 최근에 참조되었고 0은 참조되지 않은 것, 시계 방향으로  돌면서 0을 찾고 찾는 순간 프로세스를 교체하고 1로 바꾸는 알고리즘
    - LFU : 가장 참조 횟수가 적은 페이지를 교체