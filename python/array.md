# ✂정렬

복습: No
유형: algorism
작성일시: 2022년 8월 8일 오전 9:55

## 알고리즘 이란?

- 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법 or 컴퓨터가 어떤일을 수행하기 위한 단계적 방법
- 의사코드(슈도코드)

```python
CalcSum(n)
	sum ← 0
	for i : 1 →  n
		sum ← sum + i
	return sum;
```

- 순서도

![캡처.PNG](%E2%9C%82%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%201ff17a57a2b14a9cb95403286a42462c/%25EC%25BA%25A1%25EC%25B2%2598.png)

- 좋은 알고리즘이란?
    1. 정확성 : 얼마나 정확하게 동작하는가
    2. 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가
    3. 메모리 사용량 : 얼마나 적은 메모리를 사용하는가
    4. 단순성 : 얼마나 단순한가
    5. 최적성 : 더 이상 개선할 여지없이 최적화 되었는가

## 🎈시간 복잡도(Time Complexity)

- 빅-오(O) 표기법
    
    ```html
    O(n**2 + n + 2) = O(n**2)
    O(3n - 2) = O(3n) = O(n)
    O(4) = O(1)
    ```
    
    ![캡처.PNG](%E2%9C%82%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%201ff17a57a2b14a9cb95403286a42462c/%25EC%25BA%25A1%25EC%25B2%2598%201.png)
    

## 그래비티

: 배열 활용

![캡처.PNG](%E2%9C%82%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%201ff17a57a2b14a9cb95403286a42462c/%25EC%25BA%25A1%25EC%25B2%2598%202.png)

## 🎈정렬 종류

- 버블 정렬 (Bubble Sort)
- 카운팅 정렬 (Counting Sort)
- 선택 정렬 (Selection Sort)
- 퀵 정렬 (Quick Sort)
- 삽입 정렬 (Insertion Sort)
- 병합 정렬 (Merge Sort)

| 알고리즘 | 평균 수행시간 | 최악 수행시간 | 알고리즘 기법 | 비고 |
| --- | --- | --- | --- | --- |
| 버블 정렬 | O(n^2) | O(n^2) | 비교와 교환 | 코딩이 가장 쉽다  |
| 카운팅 정렬 | O(n+k) | O(n+k) | 비교환 방식 | n이 비교적 작을 때만 가능(최대 있음) |
| 선택 정렬 | O(n^2) | O(n^2) | 비교와 교환 | 교환의 횟수가 버블, 삽입보다 작다 |
| 퀵 정렬 | O(n log n) | O(n^2) | 분할 정복 | 최악의 경우 O(n^2)이지만, 평균적으로는 가장 빠르다 |
| 삽입 정렬 | O(n^2) | O(n^2) | 비교와 교환 | n의 개수가 작을 때 효과적이다. |
| 병합 정렬 | O(n log n) | O(n log n) | 분할 정복 | 연결리스트의 경우 가장 효율적인 방식 |

## 버블정렬

인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식

- 응용 : 오름차순 또는 내림차순을 적용하는데 사용
- 시간 복잡도 : O(n^2)

![캡처.PNG](%E2%9C%82%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%201ff17a57a2b14a9cb95403286a42462c/%25EC%25BA%25A1%25EC%25B2%2598%203.png)

```python
#1. sol

import sys
sys.stdin = open('input.txt')

# 인풋값 호출
nums = list(map(int, input().split(', ')))

# 인풋 리스트의 마지막 값들을 하나씩 줄여나간다
for i in range(len(nums)-1, 0, -1):

    # 정리된 리스트를 돌아가며
    for j in range(i):
        # 현재인덱스값이 다음 인덱스값보다 크면
        if nums[j] > nums[j+1]:
            # 자리를 바꾼다 (큰 수를 뒤로 넘긴다)
            nums[j], nums[j + 1] = nums[j+1], nums[j]

print(nums)
```

## 카운팅 정렬

항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘

- 어느정도 정렬이 되어 있지 않다면 계산 양이 너무 커진다.
- 제한 : 정수표현 된 자료에서만 가능
- 카운트 배열의 최대 크기 : 백만

![캡처.PNG](%E2%9C%82%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%201ff17a57a2b14a9cb95403286a42462c/%25EC%25BA%25A1%25EC%25B2%2598%204.png)

```python
#1. sol

import sys
sys.stdin = open('input.txt')

# A = 인풋 리스트 생성
A = list(map(int, input().split(', ')))
# B = 카운트 리스트 생성
B = [0 for _ in range(len(A))]     # or B = [0] * len(A)

for i in A:                        # 카운트 리스트에 카운트 값 저장
    B[i] += 1
#print(B)

for i in range(len(B)-1):          # 카운트 리스트에 카운트들 누적합 저장
    B[i+1] += B[i]
#print(B)

ans = [0 for _ in range(len(A))]   # 정렬된 리스트를 넣기위한 새로운 리스트 생성
for i in reversed(A):              # 인풋 리스트 역순으로 진행
    ans[B[i]-1] = i                # 인덱스로 계산하니까 -1
    B[i] -= 1                      # 입력값에 중복을 방지하기 위해 -1
print(ans)
```

참고 site : [https://velog.io/@good159897/안정-정렬-VS-불안정-정렬-파이썬-알고리즘-인터뷰](https://velog.io/@good159897/%EC%95%88%EC%A0%95-%EC%A0%95%EB%A0%AC-VS-%EB%B6%88%EC%95%88%EC%A0%95-%EC%A0%95%EB%A0%AC-%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%9D%B8%ED%84%B0%EB%B7%B0)

## 완전 검색

---

문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법

Btute-force 혹은 generate-and-test 기법이라고도 함

모든 경우의 수를 테스트한 후, 최종 해법을 도출함

일반적으로 경우의 수가 상대적으로 작을 때 유용함

## 탐욕(greedy) 알고리즘

---

최적해를 구하는 데 사용되는 근시안적인 방법

여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달함

각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그 것이 최적이라는 보장은 없다.

일반적으로, 머릿속에 떠오르는 생각을 검증없이 바로 구현하면 Greedy접근이 된다.

## ****2차원 배열의 접근****

 n x m 배열의 n * m 개의 모든 원소를 빠짐없이 조사하는 방법

---

- 행 우선 순회0
    
    ![1.PNG](%E2%9C%82%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%201ff17a57a2b14a9cb95403286a42462c/1.png)
    
- 열 우선 순회
    
    ![2.PNG](%E2%9C%82%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%201ff17a57a2b14a9cb95403286a42462c/2.png)
    
- 지그재그 순회0
    
    ![3.PNG](%E2%9C%82%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%201ff17a57a2b14a9cb95403286a42462c/3.png)
    
- 델타 배열 탑색
    
    ![1.PNG](%E2%9C%82%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%201ff17a57a2b14a9cb95403286a42462c/1%201.png)
    
- 전치 행렬

![2.PNG](%E2%9C%82%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%201ff17a57a2b14a9cb95403286a42462c/2%201.png)

## 비트 연산자

```html
& : 비트 단위로 AND 연산
| : 비트 단위로 OR 연산
<< : 피연산자의 비트 열을 왼쪽으로 이동시킨다.
>> : 피연산자의 비트 열을 오른쪽으로 이동시킨다.
ex) n = 10
print(n<<1)  #10을 2배 한 값인 20 이 출력된다.
print(n>>1)  #10을 반으로 나눈 값인 5 가 출력된다.
print(n<<2)  #10을 4배 한 값인 40 이 출력된다.
print(n>>2)  #10을 반으로 나눈 후 다시 반으로 나눈 값인 2 가 출력된다.
```

- i&(1<<j) : i의 j번째 비트가 1인지 아닌지를 검사
    
    훨씬 짧게 쓸수 있기 때문에 사용함
    

```python
arr = [1, 2, 3]

n= len(arr)
for i in range(1<<n):
    for j in range(n):
        if i & (1<<j):
            print(arr[j], end=", ")
    print()
print()

```

## **부분집합 생성**

### **부분집합 합(Subset Sum) 문제**

- 유한 개의 정수로 이루어진 집합이 있을 때, 이 집합의 부분집합 중에서 그 집합의 원소를 모두 더한 값이 0이 되는 경우가 있는지를 알아내는 문제
- 예를 들어 [-7, -3, -2, 5, 8] 라는 집합이 있을 때, [-3, -2, 5]는 이 집합의 부분집합이면서 합이 0 이므로 이 경우의 답은 참이 된다.

### **부분집합의 수**

- 집합의 원소가 n개일 때, 공집합을 포함한 부분집합의 수는 2^n 개이다
- 이는 각 원소를 부분집합에 포함시키거나 포함시키지 않는 2가지 경우를 모든 원소에 적용한 경우의 수와 같다.
- 부분 집합 구하는 방법

```python
arr = [7, 2, 5, 3, 4, 3]
N =len(arr)

for i in range(N-1):
	minIdx = I
		for j in range(i+1, N):
			if arr[minIdx] > arr[j]:
				minIdx = j
		arr[minIdx], arr[i] = arr[i], arr[minIdx]
print(arr)
```

[부분집합 구하는 방법 이해하기 (1)](https://www.notion.so/f4c43bb886a84935ac93f532245f5fd8)

## **검색**

### **목적하는 탐색 키를 가진 항목을 찾는 것**

- 탐색 키 : 자료를 구별하여 인식할 수 있는 키

### **검색의 종류**

- **순차 검색**
    - 가장 간단하고 직관적인 검색 방법
    - 배열이나 연결 리스트 등 순차구조로 구현된 자료구조에서 원하는 항목을 찾을 때 유용함
    - 알고리즘이 단순하여 구현이 쉽지만, 검색 대상의 수가 많은 경우에는 수행시간이 급격히 증가하여 비효율적임
- **이진 검색**
    - 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법
    - 이진 검색을 하기 위해서는 자료가 정렬된 상태여야 한다.
- **해쉬**

### **인덱스**

- 인덱스라는 용어는 Database에서 유래했으며, 테이블에 대한 동작 속도를 높여주는 자료 구조를 일컫는다. Database 분야가 아닌 곳에서는 Look up table등의 용어를 사용하기도 한다
- 인덱스를 저장하는데 필요한 디스크 공간은 보통 테이블을 저장하는데 필요한 디스크 공간보다 작다. 왜냐하면 보통 인덱스는 키-필드만 갖고 있고, 테이블의 다른 세부 항목들은 갖고 있지 않기 때문이다.

## **선택 정렬**

### **선택정렬이란?**

- 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식
- 앞서 살펴본 셀렉션 알고리즘을 전체 자료에 적용한 것이다.

### **정렬 과정**

- 주어진 리스트 중에서 최소값을 찾는다.
- 그 값을 리스트의 맨 앞에 위치한 값과 교환한다.
- 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복한다.

### **시간 복잡도**

- O(n2)

## **셀렉션 알고리즘**

### **셀렉션 알고리즘이란?**

- 저장되어 있는 자료로부터 k번쨰로 큰 혹은 작은 원소를 찾는 방법을 셀렉션 알고리즘이라 한다.
- 최소값, 최대값 혹은 중간값을 찾는 알고리즘을 의미하기도 한다

### **선택 과정**

- 셀렉션은 아래와 같은 과정을 통해 이루어진다.
    - 정렬 알고리즘을 이용하여 자료 정렬하기
    - 원하는 순서에 있는 원소 가져오기

### 병합정렬

![YlHqG.gif](%E2%9C%82%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%201ff17a57a2b14a9cb95403286a42462c/YlHqG.gif)

![https://user-images.githubusercontent.com/39042837/110721568-271ce180-8254-11eb-8957-f3b2c0e172fb.gif](https://user-images.githubusercontent.com/39042837/110721568-271ce180-8254-11eb-8957-f3b2c0e172fb.gif)

### 이진 탐색

![https://blog.penjee.com/wp-content/uploads/2015/04/binary-and-linear-search-animations.gif](https://blog.penjee.com/wp-content/uploads/2015/04/binary-and-linear-search-animations.gif)